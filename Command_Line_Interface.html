<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Browser Terminal Emulator</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.0.1/codemirror.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.0.1/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.0.1/mode/shell/shell.min.js"></script>

  <style>
    :root { --bg: #1e1e1e; --text: #d4d4d4; --prompt: #4ec9b0; --border: #3c3c3c; --editor-bg: #252526; --dir: #81a1c1; --file: #d4d4d4; --error: #ff6b6b; --modal-bg: #2d2d2d; --modal-border: #555; --status-bg: #333; --status-text: #ccc; --line-num: #555; }
    body { margin:0; font-family:monospace; background:var(--bg); color:var(--text); height:100vh; display:flex; flex-direction:column; overflow:hidden; }
    #terminal { flex:1; padding:1rem; overflow-y:auto; background:var(--editor-bg); }
    .output-line { margin:0.2rem 0; white-space:pre-wrap; }
    .prompt { color:var(--prompt); }
    .error { color:var(--error); }
    .dir { color:var(--dir); font-weight:bold; }
    .file { color:var(--file); }
    #input-container { display:flex; align-items:center; padding:0.5rem 1rem; background:var(--bg); border-top:1px solid var(--border); }
    #prompt { color:var(--prompt); margin-right:0.5rem; }
    #input { flex:1; background:none; border:none; color:var(--text); font-family:monospace; font-size:1rem; outline:none; }
    #modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:200; justify-content:center; align-items:center; }
    #editor-modal { width:90%; max-width:1100px; height:85vh; background:var(--modal-bg); border:1px solid var(--modal-border); border-radius:6px; display:flex; flex-direction:column; }
    #editor-header { padding:0.6rem 1rem; background:#222; border-bottom:1px solid var(--modal-border); display:flex; justify-content:space-between; align-items:center; }
    #editor-title { margin:0; font-size:1.1rem; }
    #editor-status { padding:0.4rem 1rem; background:var(--status-bg); color:var(--status-text); font-size:0.9rem; border-top:1px solid var(--modal-border); text-align:center; }
    #editor-buttons button { margin-left:0.8rem; padding:0.4rem 0.9rem; background:#0066cc; color:white; border:none; border-radius:4px; cursor:pointer; }
    #editor-buttons button:hover { background:#0055aa; }
    #editor-container { flex:1; overflow:hidden; }
    #search-bar { display:none; padding:0.5rem; background:#333; border-top:1px solid var(--border); }
    #search-input { background:#444; border:1px solid #555; color:#ddd; padding:0.3rem; width:80%; }
    .cm-lineNumbers .cm-gutterElement { color:var(--line-num); padding:0 0.5rem; }
  </style>
</head>
<body>

<div id="terminal"></div>

<div id="input-container">
  <span id="prompt">american@browser:\~$</span>
  <input type="text" id="input" autocomplete="off" autofocus />
</div>

<div id="modal">
  <div id="editor-modal">
    <div id="editor-header">
      <h2 id="editor-title">Nano Editor: </h2>
      <div id="editor-buttons">
        <button id="btn-save">^O Write Out</button>
        <button id="btn-search">^W Where Is</button>
        <button id="btn-exit">^X Exit</button>
      </div>
    </div>
    <div id="editor-container"></div>
    <div id="search-bar">
      <input type="text" id="search-input" placeholder="Search for..." />
      <button id="btn-search-next">Next</button>
      <button id="btn-search-close">Close</button>
    </div>
    <div id="editor-status">^G Help  ^O WriteOut  ^R ReadFile  ^W WhereIs  ^X Exit  (Nano simulation)</div>
  </div>
</div>

<script>
// ────────────────────────────────────────────────
//  IndexedDB Persistence
// ────────────────────────────────────────────────

const DB_NAME = 'BrowserFS';
const DB_STORE = 'filesystem';
let db;

async function initDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      db.createObjectStore(DB_STORE, { keyPath: 'path' });
    };
    req.onsuccess = e => {
      db = e.target.result;
      resolve();
    };
    req.onerror = e => reject(e.target.error);
  });
}

async function loadFS() {
  await initDB();
  return new Promise((resolve) => {
    const tx = db.transaction(DB_STORE, 'readonly');
    const store = tx.objectStore(DB_STORE);
    const req = store.getAll();
    req.onsuccess = e => {
      const entries = e.target.result;
      fs = {'/': { type:'dir', contents: {}, mtime: new Date(), mode: 0o755 }};
      if (entries.length === 0) {
        // Default FS
        fs['/'].contents = {
          home: { type:'dir', contents: {
            american: { type:'dir', contents: {
              'notes.txt': { type:'file', content:'Welcome to your persistent terminal.\n', mtime:new Date(), mode:0o644 }
            }, mode:0o755 }
          }, mode:0o755 }
        };
      } else {
        entries.forEach(entry => {
          let node = fs;
          const parts = entry.path.split('/').filter(Boolean);
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!node.contents[part]) node.contents[part] = { type:'dir', contents:{}, mode:0o755 };
            node = node.contents[part];
          }
          node.contents[parts.pop()] = entry.node;
        });
      }
      resolve();
    };
  });
}

async function saveNode(path, node) {
  const tx = db.transaction(DB_STORE, 'readwrite');
  const store = tx.objectStore(DB_STORE);
  store.put({ path, node });
  await tx.done;
}

async function persistFS(path = '/', node = fs['/']) {
  await saveNode(path, { type: node.type, content: node.content, mtime: node.mtime, mode: node.mode });
  if (node.type === 'dir') {
    for (const [name, child] of Object.entries(node.contents || {})) {
      await persistFS(`\( {path === '/' ? '' : path}/ \){name}`, child);
    }
  }
}

// Load FS on start
loadFS();

// ────────────────────────────────────────────────
//  File System Helpers & Commands
// ────────────────────────────────────────────────

let currentDir = '/home/american';
let username = 'american';
let hostname = 'browser';

function getNode(path) {
  const parts = normalizePath(path).split('/').filter(Boolean);
  let node = fs['/'];
  for (const part of parts) {
    if (!node.contents || !node.contents[part]) return null;
    node = node.contents[part];
  }
  return node;
}

function resolvePath(rel) {
  if (rel.startsWith('/')) return rel;
  if (rel === '\~' || rel.startsWith('\~/')) return `/home/american${rel.slice(1)}`;
  return (currentDir === '/' ? '/' : currentDir + '/') + rel;
}

function normalizePath(p) {
  let parts = resolvePath(p).split('/').filter(Boolean);
  let stack = [];
  for (let part of parts) {
    if (part === '..') stack.length && stack.pop();
    else if (part !== '.') stack.push(part);
  }
  return '/' + stack.join('/');
}

// Commands (same as previous, with chmod affecting nano open)

const commands = {
  // ... (all previous commands)
  chmod: (args) => {
    if (args.length < 2) return 'chmod: missing operand';
    const modeStr = args[0];
    const path = args[1];
    const full = normalizePath(path);
    const node = getNode(full);
    if (!node) return 'chmod: no such file or directory';
    let mode = parseInt(modeStr, 8);
    if (isNaN(mode)) {
      mode = node.mode;
      if (modeStr.includes('+x')) mode |= 0o111;
      if (modeStr.includes('-x')) mode &= \~0o111;
      // Add more symbolic modes as needed
    }
    node.mode = mode;
    persistFS(full, node);
    return '';
  },
  edit: (args) => {
    if (!args[0]) return 'edit: missing file';
    const full = normalizePath(args[0]);
    const node = getNode(full);
    if (node && node.type !== 'file') return 'edit: not a file';
    if (node && !(node.mode & 0o400)) return 'edit: permission denied (read)';
    if (!node) {
      // Create if writable parent
      const parentPath = full.slice(0, full.lastIndexOf('/')) || '/';
      const parent = getNode(parentPath);
      if (!parent || !(parent.mode & 0o200)) return 'edit: permission denied (write)';
      parent.contents[full.split('/').pop()] = { type:'file', content:'', mtime:new Date(), mode:0o644 };
      persistFS(full, parent.contents[full.split('/').pop()]);
    }
    openEditor(full);
    return '';
  },
  nano: (args) => commands.edit(args)
  // ... (other commands)
};

// ────────────────────────────────────────────────
//  Enhanced Nano Editor
// ────────────────────────────────────────────────

let editorInstance = null;
let currentEditingPath = null;
let isModified = false;

function openEditor(path) {
  currentEditingPath = path;
  document.getElementById('editor-title').textContent = `GNU nano 7.2     ${path} `;
  document.getElementById('modal').style.display = 'flex';
  const node = getNode(path);
  const content = node?.content || '';
  isModified = false;

  if (editorInstance) editorInstance.destroy();

  editorInstance = new CodeMirror.EditorView({
    doc: content,
    extensions: [
      CodeMirror.basicSetup,
      CodeMirror.lineNumbers(),
      CodeMirror.EditorView.lineWrapping,
      CodeMirror.EditorView.updateListener.of(update => {
        if (update.docChanged) isModified = true;
        updateStatus();
      }),
      CodeMirror.keymap.of([
        { key: "Ctrl-o", run: saveFile },
        { key: "Ctrl-w", run: toggleSearch },
        { key: "Ctrl-x", run: closeEditor }
      ])
    ],
    parent: document.getElementById('editor-container')
  });

  updateStatus();
}

function updateStatus() {
  const status = document.getElementById('editor-status');
  status.textContent = `${isModified ? '[Modified]' : ''}  Line: ${editorInstance.state.selection.main.from + 1} / ${editorInstance.state.doc.lines}  Chars: ${editorInstance.state.doc.length}`;
}

function toggleSearch() {
  const bar = document.getElementById('search-bar');
  bar.style.display = bar.style.display === 'flex' ? 'none' : 'flex';
  if (bar.style.display === 'flex') document.getElementById('search-input').focus();
}

document.getElementById('btn-search').onclick = toggleSearch;
document.getElementById('btn-search-next').onclick = () => {
  const query = document.getElementById('search-input').value;
  if (!query) return;
  const state = editorInstance.state;
  const cursor = state.selection.main.head;
  const text = state.doc.toString();
  let pos = text.indexOf(query, cursor);
  if (pos === -1) {
    pos = text.indexOf(query);  // Wrap around
  }
  if (pos !== -1) {
    editorInstance.dispatch({
      selection: { anchor: pos, head: pos + query.length },
      scrollIntoView: true
    });
  } else {
    alert('Not found');
  }
};
document.getElementById('btn-search-close').onclick = toggleSearch;

function saveFile() {
  if (!currentEditingPath || !editorInstance) return false;
  const content = editorInstance.state.doc.toString();
  const node = getNode(currentEditingPath);
  if (node && (node.mode & 0o200)) {  // Check write permission
    node.content = content;
    node.mtime = new Date();
    persistFS(currentEditingPath, node);
    isModified = false;
    updateStatus();
    append(`Saved: ${currentEditingPath}`);
  } else {
    append('Save failed: permission denied');
  }
  return true;
}

function closeEditor() {
  if (isModified && !confirm('Unsaved changes – exit anyway?')) return false;
  document.getElementById('modal').style.display = 'none';
  document.getElementById('search-bar').style.display = 'none';
  if (editorInstance) editorInstance.destroy();
  editorInstance = null;
  currentEditingPath = null;
  return true;
}

document.getElementById('btn-save').onclick = saveFile;
document.getElementById('btn-exit').onclick = closeEditor;

// Terminal I/O (unchanged)
const terminal = document.getElementById('terminal');
const inputEl = document.getElementById('input');

function append(html, cls = 'output-line') {
  const div = document.createElement('div');
  div.className = cls;
  div.innerHTML = html;
  terminal.appendChild(div);
  terminal.scrollTop = terminal.scrollHeight;
}

function runCommand(line) {
  if (!line.trim()) return;
  append(`<span class="prompt">\( {username}@ \){hostname}:\( {currentDir} \)</span> ${line}`);
  const parts = line.trim().split(/\s+/);
  const cmd = parts[0].toLowerCase();
  const args = parts.slice(1);

  if (commands[cmd]) {
    const result = commands[cmd](args);
    if (result) append(result);
  } else {
    append(`<span class="error">command not found: ${cmd}</span>`);
  }
}

inputEl.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    runCommand(inputEl.value);
    inputEl.value = '';
  }
});

// Welcome
append('Browser Terminal Emulator loaded with persistent FS.');
append('Type help for commands.');
</script>
</body>
</html>